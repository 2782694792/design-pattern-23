# 创建型模式 —— 原型模式
1. 用原型实例指定创建对象的种类，并且通过拷贝原型创建新的对象，不需要知道任何创建的细节；
2. 实现克隆 Clone 接口，通过基于多态的 Clone 虚函数以基类指针来复制派生类对象；

## 模式结构

### 抽象原型类 Prototype
    规定具体原型对象必须实现的接口（深拷贝，实现 Clone ）；

### 具体原型类 ConcretePrototype
   派生抽象原型，是被客户端使用的对象（被复制的对象），实现抽象原型所要求的接口；

### 原型辅助类
    对原型类进行集合处理（注册、添加），辅助完成指定类的类类型拷贝；

### 客户端
   声明抽象原型类，Clone 具体原型对象实例。

## 优缺点
`优点`
1. 相对于 new 创建：new 新建对象不能获取当前对象运行的状态，原型模式效率更高;
2. 相对于拷贝构造函数：拷贝构造函数涉及的类是已知的，而原型模式可以涉及未知的。

`缺点`
1. 克隆方法需要对类的功能进行全盘考虑，尤其是当类引用不支持串行化的简介对象或者引用含有循环结构时；
2. 每个派生类都需实现 Clone 接口。

## 区别其他创建型模式
1. 工厂方法适用于生产复杂，一个工厂生成单一的一种产品；
2. 抽象工厂适用于一个工厂生产多个相互依赖的产品；
3. 建造者模式着重于复杂对象的一步一步创建，组装产品同时创建过程中可以控制每个简单对象的创建；
4. 原型模式更强调从自身进行复制，创建和自己一模一样的对象。


## 使用场景
1. 资源优化：类初始化需要消耗不少的资源，其中包括数据、硬件资源等；
2. 性能和安全要求：通过 new 产生一个对象需要非常繁琐的数据准备或访问权限则可以使用原型模式；
3. 一个对象多个修改者：一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值。

### 示例
一个对象需要在一个高代价的数据库操作之后被创建，我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。