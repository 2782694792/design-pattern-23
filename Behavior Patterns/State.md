# 行为型模式 —— 状态模式

- 类的行为是基于状态而产生改变；

- 允许一个对象在其内部状态改变时改变它的行为，从而使对象看起来似乎修改了其行为；

- 在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。

## 模式组成

> 模式中，创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象

1. Context(行为类)：定义客户端感兴趣的接口，并且维护一个 ConcreteState 子类的实例，这个实例定义当前状态；

2. State(状态类)：定义一个接口，封装与 Context 的一个特定状态相关的行为；

3. ConcreteState subclasses：每一个子类实现一个与Context的一个状态相关的行为。

## 协作步骤

1. Context将与状态相关的请求委托给当前的ConcreteState对象处理；

2. Context可将自身作为参数传递给处理该请求的状态对象，这使得状态对象在必要时可以访问Context；

3. Context是客户使用的主要接口。客户端可用状态对象来配置一个Context，一旦一个Context配置完毕，将不再需要直接与状态对象打交道；

## 利弊 

`优点`

1. 封装了转换规则；

2. 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为；

3. 允许状态转换逻辑与状态对象合成一体，消除了分支语句，将状态处理分散到各个状态子类中去，每个子类集中处理一种状态；

4. 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。

`缺点`

1. 增加系统类和对象的个数；

2. 结构与实现都较为复杂；

3. 对"开闭原则"的支持并不太好，对于可切换状态的状态模式，增加新的状态类需要修改负责状态转换的源代码和对应类的源代码。

## 使用场景

- 行为随状态改变而改变；

- 条件、分支语句的代替者；

## 示例

[知乎 —— 状态模式](https://zhuanlan.zhihu.com/p/450030795)

