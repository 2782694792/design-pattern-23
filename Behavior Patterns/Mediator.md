# 行为型模式 —— 中介者模式

- 提供一个中介类，用来处理不用类之间的通信，并支持松耦合，使代码易于维护；

- 通过中介对象来封装一系列的对象交互，中介者使各个对象之间不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互；

- 又叫调停模式，它是迪米特法则的典型应用。

## 模式组成

1. Mediator: 抽象中介者，提供了 colleague 对象注册与管理对象信息的抽象方法；

2. Concrete Mediator: 具体中介者，实现抽象接口，负责**管理多个同事对象，完成各个同事角色之间的交互**动作；

3. Colleague: 抽象对象角色类，定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共动作（消息发送与接收）；

4. Concrete Colleague: 具体同事类，当需要与其他同事对象进行交互时，由**中介者对象负责**后续交互。

## 利弊

`优点`

1. 类之间各司其职，符合迪米特法则；

2. 降低对象之间的耦合，使得对象易于独立复用；

3. 将对象之间的**一对多**关联**变成一对一**的关联，提高系统灵活性，易于维护和扩展。

`缺点`

1. 由多对象之间的相互依赖转变成了中介者和多个同事类的相互依赖；

2. 同事类交互方法越多，中介者会变得越臃肿，复杂难以维护。

## 使用场景

1. 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象;

2. 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类;

3. 对象与对象之间存在大量的关联关系，若一个对象发生改变，也需要跟踪与之相关联的对象，并做出相应的处理。

## 模式扩展

采用以下两种方法来简化中介者模式：

- 不定义中介者接口，把具体中介者对象实现成为单例；

- 同事对象不持有中介者，而是在需要的时候直接获取中介者对象并调用。

## 区别观察者模式：

- 相同点：都是在抽象类 IMediator 用容器来封装要通知的目标对象，然后通过容器查找再通知目标对象；

- 不同点：中介者通知某一个对象，而观察者通知所有对象；