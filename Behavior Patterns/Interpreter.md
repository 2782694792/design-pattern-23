# 行为型模式 —— 解释器模式

- 提供了评估语言的语法或表达式的方式；

- 通过定义一个表示语言的抽象语法树（AST）以及解释器，将该语言的语法规则表示为类层次结构，并通过递归的方式实现语法的解释和执行；

- 给定一个语言，定义它的文法的一种标识，并定义一种解释器，该解释器使用该表示来解释语言中的句子；

## 模式组成

1. Expression: 抽象表达式类，即抽象语法书节点类，带有纯虚解释方法 interpret，用于将具体的表达式进行分析，解释该节点表示的语法规则；

2. ConcreteExpression: 具体的表达式类，可分为终结符表达式和非终结符表达式：

    a. 终结符表达式: 不能再分解的基本表达式，继承自抽象语法树节点类；

    b. 非终结符表达式: 由终结符表达式和其他非终结符表达式组合而成的表达式，包含多个子表达式，并实现 interpret() 函数，将子表达式的解释结果进行组合。

3. Context: 上下文类，包含带解析的表达式和将被解释的值，是连接整个语句的主要解析方式。

## 利弊

`优点`

1. 易于实现语法，解耦合。比如添加乘法解释器，只需管理本身所支持的语法；

2. 易于使用和维护。context 上下文可支持对输入的语句进行分析，以此使用不同的语法表达式进行上下文解析；

3. 可扩展。表达式语言如果不同，只需要添加新的解释器即可，如对

`缺点`

1. 执行效率低。每个表达式都需要构建和解释；

2. 复杂性。实现一个复杂的语言需要定义更多的表达式类型。

## 应用场景

- 适合简单的文法表示，复杂的文法会产生大的类层次结构，此时需要借助与语法分析器工具；

- 需要解析和执行一种特定的语言或表达式；

- 需要实现一个定制的编程语言或脚本语言；

- 需要对一些数据进行处理或转换，例如文本解析、数学表达式求值等；

- 需要提供一个高度灵活的用户界面，以允许用户以自定义方式输入和处理数据。

## 扩展

1. 递归下降解释器模式（Recursive Descent Interpreter Pattern）

> 使用手写代码来实现解释器的方法;
> 使用递归函数来实现表达式的解析和求值，不需要创建抽象语法树。
> 比基本的解释器模式更快和更灵活，但需要更多的手写代码和更高的技能水平。

2. 优化解释器模式（Optimized Interpreter Pattern）

> 一种使用缓存和预处理技术来提高解释器效率的方法。
> 例如，可以使用缓存来存储已经解析的表达式结果，避免重复计算。也可以使用预处理技术，例如将表达式转换为更简单的形式，以便更快地计算结果。

3. 编译器模式（Compiler Pattern）

> 一种将高级语言转换为机器代码的方法。
> 涉及到语法分析、语义分析、代码生成和代码优化等步骤。