# 结构型模式 —— 享元模式

1. **减少创建对象的数量**，改善应用所需的对象结构的方式，以减少内存占用、提高性能；
2. *尝试重用现有的同类对象*，如果未找到匹配的对象，则创建新对象;
3. 运用共享内存支持大量细粒度对象的复用;
4. 构建一套复用算法充分利用已存在的对象。

## 模式成员

1. **Flyweight**（抽象享元类）：一个接口或抽象类，声明了具体享元类的公共方法；
2. **ConcreteFlyweight**（具体享元类）：实现 Flyweight 接口，其实例称为享元对象；
3. **UnsharedConcreteFlyweight**（非共享具体享元类）：并非所有抽象享元类的子类都需要被共享，不强制共享；
4. **FlyweightFactory**（享元工厂类）：用于创建并管理 flyweight 享元对象（构建缓存/池/容器），合理共享，为客户端的请求提供一个已创建的示例，不存在对应示例则创建返回；
5. 客户端：维持对 Flyweight 的引用，同时，需要计算或存储 Flyweight 的外部状态。

## 模式约束

1. **内部状态** 存储于 flyweight 中，它包含了独立于flyweight场景的信息，这些信息使得flyweight可以被共享；
2. **外部状态** 取决于 flyweight 场景，并根据场景而变化，因此不可共享。用户对象负责在必要的时候将外部状态传递给 flyweight；
3. 客户端不直接对 ConcreteFlyweight 实例化，只能从 FlyweightFactory 对象获取到 ConcreteFlyweight 对象；
4. 共享一个实例，使用单例模式实现。

## 使用场景

- 一个程序使用了大量的对象，造成存储开销大；
- 对象的大多数状态可变为外部状态；
- 组合模式有时候会产生很多细粒度的对象，通过结合享元模式控制对象创建的轻量化。

## 应用实例

1. string 常量池；
2. 数据库的连接池。

## 区别

1. 和适配器模式：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 
2. 和装饰器模式：装饰器模式为了增强功能，而代理模式是为了加以控制。
3. 和单例模式：同样追求性能，但面对困难不同，单例处理多线程（锁开销大），而享元处理数据结构（需要复用算法）。


