# 结构型模式 —— 代理模式

- 也叫委托模式，由一个类代替访问另一个类；
- 通过创建具有现有对象的对象，一次向外界提供功能接口；
- 为其他对象提供一种代理以控制对这个对象的访问。

## 模式组成

1. **Subject**：抽象主题类，定义 RealSubject 和 Proxy 的*共用接口*，这样就可以在任何使用 RealSubject 的地方都可以使用 Proxy；
2. **RealSubject**：真实主题类，实现 Subject 中的具体业务，是代理对象所代表的的真实处理业务的真实角色（最终引用的对象）。
3. **Proxy**：代理类，保存一个引用使得代理可以访问实体，提供一个与 Subject 的接口相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

## 优点

- 在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
- 职责清晰：真实角色就是实现实际的业务逻辑，不关心其他非本职责的事务；
- 高扩展性：具体主题角色可变；
- 能将客户端与目标对象分离，在一定程度上降低了系统的耦合度。

## 缺点

- 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
- 增加了系统的复杂度。

## 适用场景

- 远程代理（Remote Proxy）
    > 为一个位于不同地址空间的对象提供一个本地代理，对代理的方法调用会导致对远程对象的方法调用;ATM 就是一个例子，ATM 可能会持有（存在于远程服务器中的）银行信息的一个代理对象。

- 虚拟代理（Virtual Proxy）
    > 1. 使用虚拟代理，代理可以作为一个（资源消耗较大的）对象的代表;
    > 2. 虚拟代理经常延迟对象的创建，直到需要为止。
    > 3. 在创建对象之前（及创建对象过程中），虚拟代理也可以作为对象的代理；之后，代理将请求直接委托给 RealSubject。

- 保护代理（Protection Proxy）
    > 根据访问权限，可以使用保护代理来控制对资源的访问。例如，有一个员工对象，保护代理可以允许普通员工调用对象的某些方法，管理员调用其他方法。

- 缓冲代理（Cache Proxy）
    > 为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。

- 智能引用代理（Smart Reference Proxy）
    > 当一个对象被引用时，提供一些额外的操作（例如：将对象被调用的次数记录下来）。

## 区别

1. 和适配器模式：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口；
2. 和装饰器模式：装饰器模式为了增强功能，而代理模式是为了加以控制。